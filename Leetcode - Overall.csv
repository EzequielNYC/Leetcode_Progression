Problem,Problem Name,DS,Algo,Solved ?,Big O ,Takeaways,Diffuculty,Date,Next Solve Date,Next Solve Date,Next Solve Date,Next Solve Date
DICTIONARY / HASHMAP,,,,,,,,,,,,
448,Find All Numbers Disappeared in an Array,lists,array traversal,Y,,list comprehensions,Easy,8/1,,,,
1394,Find Lucky Integer in an Array,dict,"dict traversal, sorting",Y,,using lambdas to sort dict adn return highest key where key==val,Easy,8/1,,,,
387,First Unique Character in a String,dict,dict traversal ,y,,"create dict of freq. and return the ind, where the first instance of val ==1 ",Easy,8/3,,,,
451,Sort Char by Freq,dict,"lambdas, dict traversal",Y,,,,,,,,
,,,,,,,,,,,,
,,,,,,,,,,,,
,,,,,,,,,,,,
,,,,,,,,,,,,
STRINGS,,,,,,,,,,,,
551,Student Attendance Record I,variables ,counts/incrimenting,N,,"need to get better at where to places tabs in loops. For example, in this problem, I need to make sure I checked absents, then I check consecutives lates, under the loop, by pushing it to right one tab, by doing this I am able to loop through absents first, then i loop though Ls. also practing when to put ELIF !!!",Easy,8/1,,,,
345,Reverse Vowels of a String,string/lists,Two Pointers,Y/N super close,,"Had to convert string into list, because strings are IMMUTABLE ! I also created a list of vowels to check if vowel is in list. 2 pointer comes bc we need to swap first and last occurances of vowels, when l and r are vowels we swap, we move l if the left occurance in string is not vowel and same for right, and if both arents we move both. then once the list is swapped we return list back into string ",Easy,8/1,,,,
917,Reverse Only Letters,string/lists,Two Pointers,Y,,"EXACT PROBLEM AS 345 ! we are checking for alphabet, if not move, if they are swap! ",Easy,8/1,,,,
520,Detect Capital,string,Hard coded,Y,,"Checked each case to see if capitlization is valid: 1) if all is capped TRUE 2) if all is low TRUE 3) If first char is CAP 3a) if rest of lettesrs is lower TRUE 3b) if rest of letters is cap, TRUE 4) if none of that is true FALSE",Easy,8/1,,,,
283,Move Zeroes,string,Two Pointers,y,,"If we find zero, we swap with the next non zero, use two pointers to have l be the zero checker, and right be the swapper, if not zero. can solve w 2 pointers, or for loop. for loop goes through each index, and when we find number thats not 0 we swap with the beginning , which is a intiaizled variable of 0 and incriement start by 1 after each swap",easy,8/3,,,,
242,Valid Anagram,string,sorting,y,,"we can sort both strings, and check if they are exactly the same",easy,8/4,,,,
125,Valid Palindrome,string,string manipulation. (can be 2 pointers),Y,,"the bread and butter here is, fixing the string. we must turn string into new string, with just alpha numberical chars, and all must be lowered, need to have good grasp on in built methods for this. then once we have new string, we can either compare with slicing, [:] and [::-1] or set two pointers one at start and one at end and check if they are the same . Sidebar, looks better with string comprehension instead of multiple lines for cleaning string",easy,8/8,,,,
13,Roman Int,string / dict,string manipulation,N,,"My initial thought was to create dict of roman int to num and the pair of roman ints, that deduce to another number. I iterate through string to find the deduced values, first, if they are in there , we replace that with a empty string, and incriment total with its values, then with the remainders , we loop through string and add each roman int to total. ANOTHER SOL, is to replace the deduced values with their equal counter so IX would be IIII. ",easy,8/9,,,,
58,len of last word,"string, list ","string manipulation, slicing",y,,"The string is filled with "" "" (spaces) to combine string into just words, we can split the string using split method .split(), this turns "" cat       cat   "" into ['cat','cat'] a list of the split words in string. since the last word at at the end of the list, we use sliciing to point out last item and return its len",easy,8/9,,,,
151,reverse words in string ,"string, list ","string manipulation, slicing",y,,"Use split method again to turn each word into value in list, and we return the reverse of said list using splicing again [-1]",easy,8/9,,,,
28,find ind of first occ of string,string,index method,y,,"if needle is in haystack, return the index of needle in haystack. we do this by returning haystack.index(needle) this ensure the index we find is of the needle, and it returns the starting index. THE key here is the index method ",easy,8/9,,,,
451,sort char by freq ,string / dict,sorting ,y,o(n),"return new string in desc order of values, ie the most freq char in the string must come first. we start by creating freq of string dict. each char has its freq stored in the dict. then we sort the dict using a lambda function. in this new sorted dict, we loop through each key,value pair and append it to a new string, each key * value, so return each char. then we return the new string. BLOOMBERG PROBLEM",Medium,8/14,,,,
1209,remove ajd dupes,string/stack,sorting,n,,"This problems requires us to remove each instance where there a k amount of adj values. we then repeat the removal of k adj values again after the removal, we stop once there are no k adj values. To solve this problem we can create a stack to hold both char and freq ( a stack / dict hybrid ) each value in the stack will hold the char and its value ie [(e,1),(d,3)]. we iterate through the string, and if stack is empty or the curr char is not equal to the top of stack, we can append the curr char and 1, and 1, else we incriement the curr char by 1 , if the incrimented value is equal to the k amount of adj that we can have, we pop the curr char. this should result in the final instance where we have no k values, since we are popping keeping track of adj values. then we take the first value of our stack, dict list, and adding that to the new string, its freq number of times. very similar to 451 . BLOOMBERG",,,,,,
394,decode string,string/stack,stack maniuplation,n,,"The problem is asking us to decode a string, with num, brackets and alpha chars. the data structs, needed to solve is a stack. Why stack? bc a stack lets us work through each char, and append or pop from the stack when we reach certain chars. the stack at base level will be a stack of tuples, in which we keep track of the number and the chars adj to the numbers. to do this we set 3 empty variables for the stack, number and string char. so num = 0 str = """" and stack = []. we iterate through the string and look for 3 conditions. if the char isdigit(). we store it in our curr_num variable. in cases where our num is 2 digits, we must multiply our curr num * 10 to move it over to the left, and add our num. if we find a [, we then append our curr num and curr str to a the stack in tuple format. the resulting would be a tuple of the curr_num and a empty string to append the char we find. we then reset our num and string variables to prepare for another open bracket. if we find a ] then we assume we added the chars to our curr string and our most recent tuple in the stack reflects the inner most char with num. we assign 2 variables to be equal to the num and char of the most recenet tuple, and we set our curr str to be the resulting of the variable we assigned to prev num, and the variable of prev string * curr string. else: this means we found a char, we updates curr_str to the char. we return our curr_str. Bloomberg problem",,,,,,
344,reverse string,string,"2 pointers, start,stop,step",y,o(n),"reverse string by 2 pointers, l =0 r = len(string)-1, correct final index. swap them and then incriment. o of n bc we are going to swap for as much chars we have in the string.they each get touched.",,,,,,
,,,,,,,,,,,,
ARRAYS ,,,,,,,,,,,,
344,Reverse String,array,Start:Stop:Step / Two Pointers,Y,,"REVERSE ARRAY: Solution 1: make array equal to itself by stepped backwards-1 | s[:]=s[::-1] or TWO POINTERS: swap left and right pointers , left start right ending, incrimenting each time ",Easy,8/1,,,,
1431,Kids With the Greatest Number of Candies,lists,List comprehension,Y,,"This problem required us to add the extra to each number in list and check if the added number is greater than or equal to max number. In list comprehension the start of the list is where the code is implemented. then once that is done we have to start the for loop,  squared_numbers = [num ** 2 for num in range(3)] . ",Easy,8/1,,,,
485,Max Consecutive Ones - LeetCode,lists,lists traversal,Y,,"Checking to see longest consequtive of 1s. Use for loop to go through all nums, then we start count when we find 1 , we reset count if we find 0. we update our max_count in for loop for each 1 we get, and return max_count",Easy,8/1,,,,
1287,Element Appearing More Than 25% In Sorted Array,dict / list,dict/list trav,Y,,DICT: create a dict of frequencies and check if value is greater then len//4 or use for loop and count function to check if the count of num is greater than quarter of array. DICT is faster run time with o(n) count is o(n^2),Easy,8/1,,,,
238,Product of Array Except Self,lists,two pass algo,Y kinda,,"Problem: return list of product of list except itself- meaning the 0 index is the product of rest etc etc. To solve we have to create our resulting list, with the equal length of the og list with place fillers bc we need to assign each index a num. We start out first pass on the list going left to right, we assign the first value of the resulting list 1, then the following will be the product of left of the index. for our second pass, we must go right to left, the last index of our resulting list remains untouched because we calculated its value in the first path since all its numbers are left. then we iterate left with each number getting multiplied by the right of its index, resulting in the final list havin the product except self",Medium,8/2,,,,
55,Jump Game,array,Greedy,N,,"Greedy Algo : makes the best choice at each step, without consindering the overall problem struct/future consequences. In this problem, we use greedy because we only care if each iteration surpasses the farther index possible. if the current index is greater than the furthest index possible, we know this list is not able to jump from start to end. if ind is always less than or equal its furthest value (ind+num) we know it is able to jump inside the list from start to end. In conclusion, we start our furtherst_index_possible to 0 because we are going to update it with our first iteration. Once start our for enumerate loop, we are going to check if the ind > futherest_ind_possible. if it is we return false because we know that list will never reach the end, we then update our furtherst posssible ind to the max of itself, or the curr num+ind. doing this we finding the fartherst this iteration is able to go, and we then check if the fartherst is smaller than our next index. if our ind is always greater, we will return true outside of for loop",Medium,8/2,8/3,,,
45,Jump Game II,Array,Greedy,N,,"Similar to jump Game I, this problem requires us to find the mininmum amount of steps needed to reach end of the list. Since this is a Greedy algo, we do not care about the actual amount of jumps,but the max amount of jumps at each interation. IE, we start with steps. max_jump and final_jump variables, this is to keep track of number of steps taken, the farthest we can go, and the final_jump of where our max_jump takes us. we start the loop , and in loop we updates max_jump with either the max of max_jump or the ind+num. we then chcek to see if our curr index, is at the final_jump we are able to go to. since we are first starting and final jump is 0 and so is i, YES we reached it. so we then update, our final_jump with the max_jump we can go to and incriment steps by 1. on the next iteration, we update max_jump again, this make sure we are keeping record of each highest step we can take while we are going to the final step of curr max. once we reach the final step , we then update our final step with the max we found while interatiing. All in all, this will ensure, that the max amount of steps found while we are jumping is being stored, then used, until we reach final index.",Medium,8/8,,,,
605,Can Place Flowers,arrays,List traversal / single pointer,N,,"Checking to see if I can place n number of 1s in between two 0s, ie 101010. The solution starts intiating our pointer and counter. we traverse list while pointer is less than len, then we check if our current iteration is 0, if it is we then check if we are the beginning or if our previous is 0, AND if we are at the end of the list, or our next val is 0. then we can put our current iteration as 1 and we +1 count. and then we incriment i. by doing this we are updating every chance we can put a 1 between two zeros. Final step, if the count we had is greater than or equal n, return True meaning, we can put at least N amount of 1s in our list, if count is smaller we get false, bc we can not put N number of s in our list",Easy,8/2,,,,
896,Monotonic Array,arrays,iterative approach,N,,"We are checking if nums in list are in increasing or decreasing order. we intialize Decrease, and Increase to be True. We then go for in range(1,len(nums)) to start at index 1 and we are going to check if decrease i < i-1 is true, if not we set Decrease to False, and same for increasing, we turn if one of them is true using Or, if both false, False, Both cant be true ",easy,8/2,,,,
121,"Best Time to Buy and Sell Stock
",Array,2 pointers,Y,,"We are checking for maxium profit, with buying one day and selling in a future date. what the 2 pointer algo is doing is, finding if the r pointer is greater than the l pointer, and saving is diff in the while loop, we update our max profit, which is set outside the loop, to the max that curr will be or the max profit of before. this code works by iterating through list, and finding where r is greater than l, in doing so we are checking where the lowest, possible L value is and the highest r value. the incriements happen, else: , bc if we find it, we update, else we incriment",easy,8/3,,,,
1,Two Sum,Array,List traversal,Y,,"We need to find the index of two numbers which add up to target. We create a dict to hold the num and ind of each value in list, as a check to see if the diff bewteen the target and curr num is in the list, if so we return the value of the num in the dict, and the curr ind, if not we populate the dict with the num and its index",easy,8/3,,,,
88,Merge Sorted Arr,arr,2 pointers,N,,"This problem gives us 2 lists, nums1 num2, and 2 numbers, m,n. Nums1 has m , number of non zero elements, and num2 and n number of non zeros. M + N = Len(nums1) CRUCIAL. The two pointers we need to use are the pos of the last  non 0 element in both list. we can acomplish this by setting a variable to m-1 and n-1. By doing this we are using the pos of the last element. we are now going to iterate while the second variable we established >= 0.showing that we reached the last number we need to merge. in the while loop we first check if our first variable is >= 0 , showing we still have numbers in the first list to merge, and if nums1[a] >nums2[b]. by doing this we are seeing which numbers need to be places at the end of list. then deincriment a by 1. ELSE: our last pos, is going to be nums2[b] since that is the greater number. deincriment by 1 . once we done that we will always deincriement the final position. TO SUMMARIZE: we are checking both lists with 2 pointers, pointing at their non zero elements, we the larger number goes to the back of the list1, deicriement whichever pointer was larger, and the pos of back.",easy,8/3,,,,
118,Pascal Triangle,"Int,lists",Nested for loop,Y,," in this problem we are tasked to create n number of rows, in which each num is the direct sum of the two numbers above it. to start we have to create a list of lists , then we will append 1s to the amount of its level, 1 lists has one 1 , second list has 2 etc, etc. once that is created we then create another for loop, in range of (1,i) this leaves out the first and last nums since they are always going to be 1. we then create our variable which equals to the nums we have to update and equal that to the previous lists, j-1 and j. the second for loop will update all nums between 1 and i with the 2 values above it. ",easy,8/3,,,,
122,"Best Time to Buy and Sell Stock
 II",Array,Array Traversal,N,,"The probelm is an extension of buy sell stock I, with the diff being, you are able to buy and sell same day and return the max profit of array. The problem is solved by creating a running profit if the curr iteration is greater then the prev, if it is we add it, if not we move on. we do this with a for loop starting at index 1.",Medium,8/7,8/8 Y,,,
136,Single Number,Array / Dict,"List/Dict Trav, bitwise Ops",Y/N,,"Solved with dict, return value ==1 and bitwise op, using compare variable of 0 and ^= for each num, this results in the same two numbers canceling out, and leaving the unique number",Easy,8/7,,,,
1732,Find Highest Alt,lists,prefix sum,Y,,"Create another list of Alt, holding all possible positions. Since this new list, is len of og list +1 we create that amount of spaces of all 0s. we iterate through the len of gains, start at 1 to end of new list, and the index i of new list is the sum of gains up to i. Solved first try :)",Easy,8/7,,,,
628,max product of 3nums,array,slicing,Y,,"find max product of 3 nums. Started by sorting nums, we then return the product of the lowest 2 nums and highest 1 or the 3 highest.",Easy,8/7,,,,
268,missing num,array,num arthmatic ,N,,"the problem is asking us to find the missing num in nums from the range of len(nums) , ie list of 0,1,3. we have a len of 3, so the numbers we need are 0,1,2,3. we are missing the number 2. to solve this problem in o of n time, we can find the natural sum of the range of nums by multiplying len of nums to len(nums+1) dividing that by 2 and subtracting with the curr sum. this diff is going to be the missing num we need bc if we add the missing num to curr sum we should get the natural sum of all numbers",Easy,8/7,,,,
217,Contains Dupe,"array,dict,set","2 pointers, list trav,dict trav, set trav",Y,,"Few ways to solve, create set of unique through iteration and if we have number already in there, True. If any value greater than 1 , True , 2 Pointers, if we find 2 adj num in sorted nums, True ",Easy,8/11,,,,
414,3rd max num,array / set,Array Traversal,y,o(n),"only care about unique values so turn list into ordered set. in the new set, we check if the len is less than 3 meaning we dont have 3 numbers to compare, we return the max, if we do have 3 numbers to comapre are return the 3rd largest, since it is sorted, we return the index of -3 which is the 3 highest",easy,8/14,,,,
349,Intersection of two arrays,array/set,Array Traversal,y,o(n),"2 lists of nums. only need to return unique numbers in both list. we turn first list into a set, and iterate through 2nd list and compare it to the set of list 1 and append the number if it is in set into another set, to make sure we return only unique values",easy,8/14,,,,
350,Intersection of two arrays II,array dict,Array Traversal,y,o(n),"same as ^ except we return all of the same numbers, each time they appear. we make a dict of freq of list 1 and iterate throgu list 2 and we decrinriment the value if we find it num in nums2 in the dict and append that to a new list. we make sure the num in nums2 is in dict and the value is greayer than 0, and we deincriment to make sure we dont add values we not supposed to ",easy,8/14,,,,
189,rotate array,array manipulation,Array Traversal,N,,"we are given K number of steps to rotate array. We must find the module of k %= len(nums) first, bc if K is equal len of nums, then we just leave it as is, since it would rotate to start. then we reverse the entire array, and reverse the start:stop k on each side. ",Medium,8/15,,,,
,,,,,,,,,,,,
,,,,,,,,,,,,
Deques / Stacks,,,,,,,,,,,,
20,Valid Paraenthesis,strings/stack/dict,string traversal,NO,,"the problem requires for the char to be open and closed, adjacent for it to be valid. () {} []. to start we create a dict where the key is the left char and value is its right. )(. then we create a empty stack to append the char to. the key to this problem is , the result can only be true if we start with open and end with close. so if char is in our in our dict, we check if the last element of stack is its opener. by doing this we will appened the opener first, bc it is not a key in our dict, then our next char has to be the value of the char in dict. RECAP: check if char is in dict, if not , append to stack, if its, we check "" if stack"" to see if is not empty, and if the last element of stack is the value of char in the dict aka the opener, if it is we pop stack, if not we return false. At the end we return not stack, bc if it is empty True, if not False ",easy,8/3,,,,
,,,,,,,,,,,,
,,,,,,,,,,,,
,,,,,,,,,,,,
,,,,,,,,,,,,
,,,,,,,,,,,,
,,,,,,,,,,,,
DYNAMIC PROGRAMMING,,,,,,,,,,,,
198,House Robber,List,sliding window / DP,NO :(,,"This problem was to check for the max amount of money you can steal from non adjacent houses. My intial approach was to check for even and odd but this was not needed. The solution i found was to add 3 0s to the start of list and each iteration of the list would incriment the 2or 3rd zero with the non-adjacent values, then we return max(harder than it sounds) ",Medium,8/2,,,,
53,Max SubArray,Array,Kadane Algo / DP,N,,"Kadane algo is the Max Sub Array Algo, in which we set our curr_sum and our max_sum to the first element of list. we then iterate through index1 to end of list, in this loop we update our curr_sum to the max of either our num or our curr_sum and our num. by doing this we are finding our max sum in each step. By doing this we can see if we have a greater total with 0-1 or just 1, and then we update our max sum with either our curr_sum or max_sum. the list the moves on to the next iteration, and checks if the previous curr_total is greater than the our curr interation, or curr_sum plus iteration. it updates the value of by adding the curr iteration, we find a greater sum, or we leave our curr sum to what it was. ",Medium,8/3,8/7 N,,,
70,Climbing Stairs,Int,DP,N,,"Question is asking how many ways can we climb N number of stairs. off rip we can climb either 1 step or 2 steps. in the dp solution, we create a array of N number of steps, plus 1. to create a list of how many steps it takes to get to N, including base step, which is 0. we start our loop from the 3 index, and on to n-1, and for our current i, we add the previous i-1 and i-2, because we can either take 1 step up from prev and 2 steps up from prev and we assign that to the next val in our, dp and we keep going up, we should be left with the sum of the total number of steps we can take at then end of our new DP list.",Easy,8/7,,,,
,,,,,,,,,,,,
,,,,,,,,,,,,
,,,,,,,,,,,,
,,,,,,,,,,,,
,,,,,,,,,,,,
,,,,,,,,,,,,
,,,,,,,,,,,,
Recursion,,,,,,,,,,,,
1342,Number of Steps to Reduce a Number to Zero,Int,Recursion,N,,"Have to call function inside of itself. In this case if number is even we /2 then we return the divided number and outside of the return we count 1, if odd we sub 1 and count +1 again. ithe final number will always result to 0 and when we get 0 we return 0. So the code will start with, if num == 0, because we will eventually get there, then the even/odd code next.",Easy,8/2,,,,
,,,,,,,,,,,,
,,,,,,,,,,,,
,,,,,,,,,,,,
Trees,,,,,,,,,,,,
,,,,,,,,,,,,
,,,,,,,,,,,,
,,,,,,,,,,,,
,,,,,,,,,,,,
,,,,,,,,,,,,
,,,,,,,,,,,,
,,,,,,,,,,,,
Heaps,,,,,,,,,,,,
,,,,,,,,,,,,
,,,,,,,,,,,,
,,,,,,,,,,,,
,,,,,,,,,,,,
,,,,,,,,,,,,
,,,,,,,,,,,,
Linked Lists,,,,,,,,,,,,
206,Reverse Linked List,Linked List,LL Iteration,Y,,"When reversing a linked list we need keep track of 3 positions, prev,curr,next. We establish our curr and prev variables before we iterate though LL. then in linkedlist we reverse by shifting the curr pointer to prev. In this step there is a missing pointer between curr and next, to fix this we move our pointers up with prev now curr, and curr now curr.next. we then repeat the same process, with curr pointer being equal to prev. this connects the two nodes, and then we move on again. when this is done we return prev, will by our last curr, with all the pointers going reversed/",Easy,8/3,,,,
21,Merged Linked List,Linked List,LL Iteration,Y/N,,"The idea for this problem is to create a empty linked list, and its head as 2 different variables. Then we iterate through both LL while they are not None, and compare each value, we add the smaller value between the list into our dummy, and incriment list, for each iteration we must move the dummy up to populate dummy corretly(do this outside of loop) when we get to a point where one is empty, we must create 2 seperate if statements for each, saying is one is not empty, our dummy list is the rest of either list1 or list2. then we return our dummy.next to show entire list",Easy,8/3,,,,
2,add two numbers ,linked list ,LL Iteration,N,,"Problem is asking us to sum the two linked list and return their values. In this problem we start by creating a empty LL, LL head, and CARRY ( very important). we then iterate through both lists while they exisit and the if we have a carry. the carry is crucial because if we go through list and we still have a carry we need to assign that. in the loop we create 2 variables which equal to both list val of their nodes. and then another variable addidng both vals and carry. we then divide val by 10 to find the carry and % 10 to find the val . we update the curr.next to the ListNode(val) and then we incriment the curr to its next, and l1 and l2 to its next if exisit else NONE and we return Dummy.next",Medium,8/3,,,,
,,,,,,,,,,,,
,,,,,,,,,,,,
,,,,,,,,,,,,
,,,,,,,,,,,,
,,,,,,,,,,,,
Bit Manipulation,,,,,,,,,,,,
7,reverse integer,int,bit manipulation,N,,"the problem is asking to see if the reversed int, falls in the 32-bit integer range. We must know before hand to check if a value is in this range we have to use 2**31. our int has to be less than that. to start the problem we must determine if the number is pos or negative, we can do that by assigning a varible to 1 or -1 if our int is large or smaller than 0. then we reverse the interger by multiplying our int and 1 or -1, this ensures our negative values will turn into a interger. then we wrap this around a str method so we can apply [::-1] to reverse and wrap that around the int method to return it back into a int. we the return our new rev int with our 1 or -1 to return our number back to its original pos or neg value, and we multiply this by the (rev < 2**31) this checks if the number falls into the bit range, and if its true we return the rev numeber * 1 or -1 to ensure the correct output",Medium,8/3,,,,
136,Single Number,Array / Dict,"List/Dict Trav, bitwise Ops",Y/N,,"Solved with dict, return value ==1 and bitwise op, using compare variable of 0 and ^= for each num, this results in the same two numbers canceling out, and leaving the unique number",Easy,8/7,,,,
,,,,,,,,,,,,
,,,,,,,,,,,,
,,,,,,,,,,,,
Sorting Searching ,,,,,,,,,,,,
692,Top k freq words,dict/array,"counting, sorting",N,,"I was very close to solving this problem. We start with creating a dict of frequencies ( i got this 100%) then we have to sort the freq dict. we can do this with a lambda function. in this we start with the sorted method and in this we are starting with freq.keys() since the key is what we want to return, then we use the lambda method to isolate the word , key = lambda word : ... after this we are going to sort the values in desc order with a -dict[word] to sort values high to low then COMMA , word to sort the sorted values by words in alpha order if they are the same outside of the sorted method we slice it by [:k] to only return the values we want and return this ",Medium,8/4,,,,
,,,,,,,,,,,,
,,,,,,,,,,,,
,,,,,,,,,,,,
Graphs,,,,,,,,,,,,
463,Island Permiter,"Graphs , list of lists",graph traversal,N,,"The question is asking to return the permiter of islands (1) in the graph. to solve this problem we can check if the current island has water(0) or if its at the edge on all sides on island. if we have water or at the edge of the side at the current 1 then we add 1 to permiter, return permiter ",Easy,8/4,,,,
,,,,,,,,,,,,
67,,,,,,,,,,,,