Problem,Problem Name,DS,Algo,Solved ?,Big O ,Why,Takeaways,Diffuculty,Date,Next Solve Date,Next Solve Date,Next Solve Date,Next Solve Date
Array / String,,,,,,,,,,,,,
88,Merge Sorted Array,Array,2 pointer,Y,o(m+n) = o(n),the algo grows linearly with the size of m and n. we can round this to big o(n) meaning the algo is running in linear time,"two ways to solve problem. Lazy and Manual. Lazy way is to add the second array of numbers to end of the first array, and use sort method. Manual way: create three check variables, 1) m-1 2)n-1 3) m+n -1. we do this to store the pos where we have nums in both arrays, and the finals pos of nums1. we then create a while loop to check FIRST, while b >=0, this checks if we have numbers in our 2nd array to compare: then in the while loop, if we have a >=0, we have numbers in first array to compare, AND, we then check for greater values, to equal to our nums1[pos] ( the third varibale we created). we insert the greater number of both then we deincriment down, either a or b in their respecitve if statement, and always deincriement pos. No need to return since, we modified in place",Easy,8/15,,,,
27,Remove Element ,Array,Array Traversal,Y,o(n),Use 1 for loop to iterate through all numbers in array. its linear bc we are at the mercy of the len of array.,"Problem is asking to modify array in place, with the numbers that are not equal to val are placed at the start of array and return the amount of nums not equal to val. To begin, we create a start varibale which is equal to 0, this will help us move nums into the start of the list, and hold the value of how many nums we have that are not equal to 0. we for loop through array, and if num does not equal val, nums[start] equal val and incriement start by 1. then return start, since it holds the amount of nums which are not equal to val, and the array should be updated to show the non val numbers in the front",Easy,8/15,,,,
80,Remove Duplicates,Array/Dict,Array/Dict Traversal,Y,o(n),"bc we iterate through list once, and add to array or dict","WE create empty dict to store freq. we run through array, and check if num is already in freq, then if the value is less than 2, if it is we append num to new list, outside of append we are always going to incriement, if not in then we assign the num to key with a value of 1. we then store array with nums we can fit, and store that back into the original array",Medium,8/16,,,,
169,Majority Element,Array/Dict,Array/Dict Traversal,Y,o(n),"traverse through array once, and dict once",assign each key their value in freq in dict. traverse through dict and return key whose value is greater than half of the len of list,Easy,8/16,,,,
189,rotate array,array manipulation,Array Traversal,Y,o(n),"we are iterating through nums, k amount of times, and len amount of times to reverse 3 times. this is all seperate from each other , so o(n) three times can be simplified to o(n)","we are given K number of steps to rotate array. We must find the module of k %= len(nums) first, bc if K is equal len of nums, then we just leave it as is, since it would rotate to start. then we reverse the entire array, and reverse the start:stop k on each side. ",Medium,8/16,,,,
121,buy sell stock,array,2 pointers ,y,o(n),"we use two pointers to solve, and the pointers are going until the end of the list, so it is linear since it is affected by the len of the list","2 pointers. create variable for max_p to store the highest num we find. we iterate thorugh list while our r pointer is less the len of list, to go thru each num. we find where right is bigger than left and store that into the loop under a variable. we then update our max_p with the highest value between curr and what maxp is already. we then incriement the right to find the curr profit of day we buy from that curr num we are on, and once we reach the end we move the left pointer up. we can either move right under the first if statement and then again under the else, after we move left one , we move right next to left, or in the else we set l equal to right and move r always by placind it outisde of our if.else statements",Easy,8/16,,,,
122,buy sell stock II,array,2 pointers,y,o(n),"we use two pointers to solve, and the pointers are going until the end of the list, so it is linear since it is affected by the len of the list","Same as part, but instead of keep tracking of maxProfit, we are keeping track of all possible profits. meaning when we find w r is greater than l. we update our curr with that and += to the total value. we the incriement by l by 1 and right by l + 1 to always restart the cycle",Medium,8/16,,,,
55,Jump Game,array,Greedy,N,o(n),"we iterate through the enumerate of list once, so it is linear, since we are going thru whole list.","# greedy algo : we only care about the max jumps each spot has, and if it can reach final# set empty int variable to store the farthest we can jump in list

# then we iterate though the enumerate of array

# we then compare if the curr index, is greater than the fartherst we can go, why ?
# we do this bc if we get to an index, which is past the farthest we can go, we can not jump any more
# on the other hand , if we can continuely jump until we reach the end of the list, we know it is possible to reach the end of the list",Medium,8/16,,,,
45,Jump Game II,array,Greedy,N,o(n),"we iterate through the range of the len of list only once and we have to go through the each num in list, so its linear","Similar to Jump Game I, we have to see the farthest possible jump each iteration has. The key differences are the values we are checking and the count we need to keep track of. We need to find the mini amount of jumps it would take to reach end of list, and we will always reach end of list. So, we keep track of count and max_jump AND the curr_jump we are on. We check to see if the curr i is equal to the curr_jump, which at first it always will be. we then update the curr jump witht the max_jump and the count by 1. we then iterate through list to see where I is equal to curr jump, and when it is we do the same, update count by 1 and update curr_jump to be the max. the problems ends when max_jump becomes out of reach for i , and i is going to be range(len(nums)-1) since we never need i to get to the end bc we know we are going to reach the end. eventually the max_jump = curr_jump would be the end of the list, and the i will end right before leaving us with the mini amount of steps needed to reach end",Medium,8/16,,,,
274,H index,array,Array Traversal,N,o(n),"looping through list once, and reversing list, means we trav through list two times, but sepertatly, so it boils down to linear time","the H index is composed of two things. The amount of papers wrote, and the number of citations each paper has. The H index checks each paper, and their citations, and checks if the citations is greater than the amount of pagers wrote so far. index is going to be the amount of pages written, and num is going to be the number of citatinos. if our num is greater than index, than we can incriment H by 1. this is why we sort, bc timeline does not matter. so our first page will be the highest num of citatinos, and our first page we check, we incriment by one bc the number if higher, we go until we find a page with a low number of citatinos, and it being after a few pages are counted. we do not count this in the H index, bc it does not satisfy it having at least the number of papers in citiations.  ",Medium,8/16,,,,
380,InsertDeleteGetRandom,dict.array,"insert,delete,get",N,o(1),"we do not iterate thru list to perform each step, so it is constant since we only need to worry about 1 or constant space","Problem has 4 main steps. 1) Intialize 2) insert 3)remove 4) get random. First step, we need to create our data structures. The problem asks just for a array, but we create a dictionary as well to store, values and their indexes. Must keep in mind the syntax for how to do this in a class. 2) Insert : we check if the value is in our dict, since our dict is going to hold its keys as the num in array, and its value will be the index. IF it is in return False, since its already there. Then we do not need another else statement, we simply insert our val into our dict and store its value as the len of the array. meaning the value is the spot/index we are inserting. the first num would be num : 0 since the array is 0. then we append the num to our array. and return True 3) REMOVE : we check if the val is NOT in the dict, we return False, showing we can not remove since its not there. HIGH LEVEL: before we code, we must understand that in removing we must keep track of where its being removed. index. and how we would update the array. SO, we create two variables, one to hold the last val we inserted to the arr, and the another value holding the index of the value , which can be done by inputting the val in the dict. we update our dict including the last val of array to be equal to the ind of the num we want to remove. and in the array we update the spot,ind, of the val to for its value to be equal to last. CHECK POINT: we have now added the last value to the dict, with the index of the array, showing a new key.num : val.ind. replacing the val we want to remove and the spot of val in the array is now equal to the last val in array.. NEXT: we update the final spot in the array -1 with the val we want to remove. and finally we pop from both the array, and pop(val) out of the dict. Return True . FINALLY GetRandom. we return random.choice from array ",Medium,8/16,,,,
238,Product Of Arr Exc Self,array,2 PASS UP AND DOWN,Y,o(n),"we go up nums 2 times, seperatly, which denotes to one linear time of traversing through entire array ","The problem requires to create a new list, with the product of the nums except for curr num we are on. To start we create a new array, as big as the current len of array. this we can have place holders for our new values. to start problem we intiate a variable of 1. this way we can store the product of nums we iterate thru. we iterate through the range on array, and we update the first index of new array with the variable, then we update variable with product of curr num we seen. this ensures our first num, is left alone since we assigned it the blank variable, and then the next pos of new array is updated with the product of the nums to the left. we then do the same process going down, updating the new array, with the new variable. this ensures our last variable is left alone, then the next is updated with the product of those to the right, we then return our new array with the updated values",Medium,8/16,,,,
134,Gas Station,array,greedy,N,o(n),"just iterating once thru list, at mercy of len of list","We have 2 lists, one gas one cost. The Gas index, is the gas station, the value is the amout of gas you get at station. the cost is the amount of gas needed to get to next statinon. To start we create 3 variables, one to store the curr gas, total gas, and start. curr gas holds the roll over value of gas, the total shows how much we have at the end, and start holds the pos where we start our process. We begin with a for range loop, bc the indexing of both list must match. we update our total gas with gas[i] - cost[i] and same with curr. we check if curr is less than 0, if it is, we move our start, bc we know we cant start there, and reset curr. by the end of the loop, we are going to see if total gas is greater or equal to 0 meaning, we are able to go thru and return start, which is the spot where we were able to start our journey, else, it is not since we didnt have enough gas and we return -1",Medium,8/16,,,,
135,Candy,array,2 PASS UP AND DOWN,N,o(n),"iterating up and down once, boils to linear ","Problem is similar to 238. We have to create storage array, which holds dummy variables of 1, with the same len of array. The question has 2 requirments, No 0s, and nums in array must have high number than adj. Does not apply to same val adj to eachother. We start by going up from the array, start at the 1st index. we compare if I is greater than its left i-1, we do this bc we want to update the dummy arr to reflect that the val at i must be larger than l. if i is greater than, res[i] is equal to res[i-1]+1 ensuring it will always be greater. This is the goal of first pass, to ensure that ratings are kept secure. SECOND pass, going down, is going to finalize that ratings are correct, since we skipped the firs num in the first pass. We going down and we check if its left value i-1 is greater than curr val at i. if it is our res[i-1] must be updated to the max value of either its self, or value at i +1. we return sum of the new array bc we want the total amount of candies after the distributions",Hard,8/16,,,,
13,Roman To Int,array/dict,traversal,y,o(n),we loop through the ds seperatly which boils down to linear ,"create 2 dicts which show the romans to int and the deduce values to int. we iterate through our deduce dict, and see if that is in the array. if it is we incriment total with amount and replace those keys, with a empty string. we then loop through the array, and since we know the left overs would be the regular roman numbers, we incriment total with the value of each roman and return total",Easy,8/17,,,,
151,reverse words in string,string,string manipu,y,o(n),have to go through entire string,"have to split string to get each word to be its own. then join(method name) those words into a new string, starting from end of og string. return new string ",medium,8/17,,,,
Key Takeaways from String / Array Problems  Problems ,,,,,,,,,,,,,
"Algos : Two Pass / Greedy / 2 pointers / Traversals ( for loop, while loops )",,,,,,,,,,,,,
,,,,,,,,,,,,,
,,,,,,,,,,,,,
"In Built Functions :  Strings :join(iterable) / split(seperator) / replace(old,new) count(substring) find(substring) len(string) / isalnum / islapha / isnum || Arrays: len(array) / append (item) / pop(index) / insert(index,item) / remove(item) / index(item) / sort() / sorted(array) / min(array) / max(array)",,,,,,,,,,,,,
,,,,,,,,,,,,,
Two Pointers,,,,,,,,,,,,,
125,Valid Palidrome,string,2 pointer,y,o(n),both pointers have to go thorugh entire list,"Key part of the problem is cleaning the string. We need only alphanum chars, NO spaces. we can do this 2 ways. for loop to only pick chars that isalnum and add to new string, lowered. or one line using join function and inside we do the same for loop. we then have the clean string, and we could 2 pointers check start and end and incriment down , if not equal False, if we get out of loop True. or [::1] == [::-1]",Easy,8/17,,,,
329,is sub sequence ,string,2 pointer,y,o(n),both pointers have to go thorugh entire list,"checking is chars is s are in t in the exact order. we set 2 pointers one to trav through s and the other to t. we start by saying while both l and r are less than their respecive strings len, if both l and r equal each other we incriment l +=1 , outside of that we always incriement to the right bc when we find pairs, we move up and if not we move up still to find pairs. if true our L pointer should have made it to the end of the list, so we can return if l == len(s)",Easy,8/17,,,,
167,two sum II,array,dict trav,y,o(n),,Same as two sum just add 1 to return values ,Medium,8/17,,,,